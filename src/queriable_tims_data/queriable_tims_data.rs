use log::info;
use rayon::prelude::*;
use serde::Serialize;
use std::hash::Hash;
use std::rc::Rc;
use std::time::Instant;

use crate::{Aggregator, ElutionGroup, HasIntegerID, IndexedData, Tolerance, ToleranceAdapter};

/// A struct that can be queried for TIMS data.
///
/// The main idea behind this struct is to provide a generic way to query TIMS data.
/// And by that I mean that with the same interface but different imeplementations
/// on the indexing one can optimize for different access patterns.
///
/// In the same way different aggregators can be used to aggregate the results.
/// In some cases just adding the intensities might be enough, but in other cases
/// one might want to do more complex operations. (fitting a gaussian to a chromatogram for example)
///
/// Main Generic parameters:
/// - `ID`: The type of indexed data that will be queried.
///         This can also optimize the access pattern to the data. When the data is queried
///         with the `many` version of the query functions, the indexed data can optimize
///         the access pattern to the data.
/// - `TA`: The type of tolerance adapter that will be used to convert elution groups into queries.
/// - `TL`: The type of tolerance that will be used to define the search space.
///
/// Additional Generic parameters:
/// - `QP`: The type of precursor query that will be used to query the indexed data.
/// - `QF`: The type of fragment query that will be used to query the indexed data.
/// - `OE`: The type of output element that will be returned by the aggregators.
/// - `AG`: The type of aggregator that will be used to aggregate the output elements.
/// - `AE`: The type of element that will be aggregated.
///
///
/// So ... in other words ...
/// 1. `TA` converts `ElutionGroup` with `TL` into `QP` and `QF` queries.
/// 2. `ID` is queried with `QP` and `QF` queries.
/// 3. The results are aggregated with `AG` aggregators (which are generated by the factory, when passed a numeric ID).
pub struct QueriableTimsData<'a, ID, TA, TL, QF, AE, OE, AG, EG: HasIntegerID>
where
    AG: Aggregator<AE, Output = OE> + Send + Sync,
    ID: IndexedData<QF, AE>,
    TA: ToleranceAdapter<QF, EG>,
    TL: Tolerance,
{
    pub indexed_data: &'a ID,
    pub aggregator_factory: &'a dyn Fn(u64) -> AG,
    pub tolerance_adapter: &'a TA,
    pub tolerance: &'a TL,
    pub _phantom_queries: std::marker::PhantomData<QF>,
    pub _phatom_agg: std::marker::PhantomData<(AE, OE, AG)>,
    pub _phatom_elution_group: std::marker::PhantomData<EG>,
}

impl<'a, ID, TA, TL, QF, AE, OE, AG, EG> QueriableTimsData<'a, ID, TA, TL, QF, AE, OE, AG, EG>
where
    AG: Aggregator<AE, Output = OE> + Send + Sync,
    ID: IndexedData<QF, AE>,
    TA: ToleranceAdapter<QF, EG>,
    TL: Tolerance,
    EG: HasIntegerID,
{
    pub fn query(&self, elution_group: &EG) -> OE {
        let mut aggregator = (self.aggregator_factory)(elution_group.get_id());
        let prep_query = self
            .tolerance_adapter
            .query_from_elution_group(self.tolerance, elution_group);

        self.indexed_data.add_query(&prep_query, &mut aggregator);
        aggregator.finalize()
    }

    pub fn add_query_multi_group(&self, elution_groups: &[EG], aggregators: &mut [AG]) {
        let mut fragment_queries = Vec::with_capacity(elution_groups.len());

        for elution_group in elution_groups {
            let qf = self
                .tolerance_adapter
                .query_from_elution_group(self.tolerance, elution_group);

            fragment_queries.push(qf);
        }

        self.indexed_data
            .add_query_multi_group(&fragment_queries, aggregators);
    }
}

pub fn query_multi_group<'a, ID, TA, TL, QF, AE, OE, AG, FH>(
    indexed_data: &'a ID,
    tolerance_adapter: &'a TA,
    tolerance: &'a TL,
    elution_groups: &[ElutionGroup<FH>],
    aggregator_factory: &dyn Fn(u64) -> AG,
) -> Vec<OE>
where
    AG: Aggregator<AE, Output = OE> + Send + Sync,
    ID: IndexedData<QF, AE>,
    TA: ToleranceAdapter<QF, ElutionGroup<FH>>,
    TL: Tolerance,
    OE: Send + Sync,
    FH: Clone + Eq + Serialize + Hash + Send + Sync,
{
    let start = Instant::now();
    let mut fragment_queries = Vec::with_capacity(elution_groups.len());
    let mut aggregators = Vec::with_capacity(elution_groups.len());

    for (i, elution_group) in elution_groups.iter().enumerate() {
        let qp = tolerance_adapter.query_from_elution_group(tolerance, elution_group);

        fragment_queries.push(qp);
        aggregators.push(aggregator_factory(i as u64));
    }

    indexed_data.add_query_multi_group(&fragment_queries, &mut aggregators);
    let duration = start.elapsed();
    info!("Querying took {:#?}", duration);

    let microsecond_duration = duration.as_micros();
    let microseconds_per_query = microsecond_duration / elution_groups.len() as u128;
    let queries_per_second = 1_000_000.0 / microseconds_per_query as f64;

    info!("That is {:#?} queries per second", queries_per_second);
    info!(
        "That is {:#?} microseconds per query",
        microseconds_per_query
    );

    let start = Instant::now();
    let out = aggregators.into_par_iter().map(|x| x.finalize()).collect();
    let elapsed = start.elapsed();
    info!("Aggregation took {:#?}", elapsed);
    out
}

pub fn query_indexed<ID, TA, TL, QF, AE, OE, AG, FH>(
    indexed_data: &ID,
    aggregator_factory: &dyn Fn(u64) -> AG,
    tolerance_adapter: &TA,
    tolerance: &TL,
    elution_group: &ElutionGroup<FH>,
) -> OE
where
    AG: Aggregator<AE, Output = OE> + Send + Sync,
    ID: IndexedData<QF, AE>,
    TA: ToleranceAdapter<QF, ElutionGroup<FH>>,
    TL: Tolerance,
    FH: Clone + Eq + Serialize + Hash + Send + Sync,
{
    let mut aggregator = aggregator_factory(elution_group.id);
    let prep_query = Rc::new(tolerance_adapter.query_from_elution_group(tolerance, elution_group));

    indexed_data.add_query(&prep_query, &mut aggregator);
    aggregator.finalize()
}
